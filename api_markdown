### The `Board` Class

The `Board` class is a template class that represents the state of a
board at a single point in a game. We've created a `ConnectFourBoard`
subclass that handles the mechanics for you. For any `Board` instance
`board`, you have access to the following methods:

**`board.get_legal_actions()`:** Returns a python set of `Action` class
instances. Each element in the set is a valid action that can be applied
to the `board` to create a new `Board` instance. See the `Action` API
section below.

**`board.is_terminal()`:** Returns `True` if `board` is an endgame board.
Returns `False` otherwise.

**`board.current_player_id()`:** Returns an integer that represents which player
is expected to play next. For example, if this method returns 0, then the player
who is the first player in some simulation of a game should be the next one to
play an action. This is used internally in the `Simulation` class for bookkeeping,
but you will need it when you do the backup step of the MCTS algorithm.

**`board.reward_vector()`:** Returns a $n$-element tuple, where $n$ is the number
of players, that contains the rewards earned by each player at this particular
`board`. For Connect Four, $n=2$. Thus this method may return something like
`(1,-1)`, meaning the player with ID 0 had a reward of 1, and the player with ID
1 has reward -1.

### The `Action` Class

The `Action` class is for representing a single action that is meant to alter a
`board`. We have written a `ConnectFourAction` subclass for you. Instances
are hashable. For any `Action`
instance `action`, you will only need the following method:

**`action.apply(board)`:** Given a `Board` instance `board`, returns a new
`Board` instance that represents the board after that action has been
performed. If the `action` cannot be applied, an error is thrown.

### The `Node` Class

The `Node` class represents a single node in the MCTS tree that is constructed
during each iteration of the algorithm. You will be interacting with this class
the most. If you remember the algorithm, each node contains certain pieces of
information that's associated with it. For any `Node` instance `node`, you have
the following methods at you disposal:

**`Node(board, action, parent)`**: The constructor takes three arguments.
First, a `Board` instance `board` that the node will represent. Second,
an `Action` instance 'action' that represents the incoming action that created
`board`. Finally, a `Node` instance `parent`. For a root node, you would
pass `None` in for both `action` and `parent`.

**`node.get_board()`:** Returns the `Board` instance that `node` is representing.

**`node.get_action()`:** Returns the incoming `Action` instance.

**`node.get_parent()`:** Returns the parent `Node` instance.

**`node.get_children()`:** Returns a list of `Node` instances that represent
the children that have been expanded thus far.

**`node.add_child(child)`:** Add a `Node` instance `child` to the list of expanded
children under `node`.

**`node.get_num_visits()`:** Returns the number of times `node` has been visited.

**`node.get_player_id()`:** This just returns `board.current_player_id()`, where
`board` is the board that was passed into the contructor.

**`node.q_value()`:** Returns the total reward that the `node` has accumulated.
This reward is contained in a variable `node.q` that you can access if it needs
to be changed during the algorithm.

**`node.visit()`:** Doesn't return anything, but increments the internal counter
that keeps track of how many times the `node` has been visited.

**`node.is_fully_expanded()`:** Return `True` is all children that can be reached
from this node have been expanded. Returns `False` otherwise.

**`node.value(c)`**: Returns the calculated UCT value for this node. The parameter
`c` is the _exploration_ constant.

### The `Player` Class

The `Player` class represents, you guessed it, a player. You won't have to actually
deal with this class at all in this problem set. It exists for running the
simulation at the end. However, if you interested, you may look at `game.py`
to see what methods are used.

### The `Simulation` Class

The `Simulation` class is used for setting up a simulation for multiple
players to play a game. You again don't need to worry about this class, as it
is for running the simulation at the end. Refer to `game.py` if your curious
about how it works.
